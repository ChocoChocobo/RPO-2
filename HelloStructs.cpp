#include <string>
#include <Windows.h>
#include <iostream>
#include "stack.h"

class PersonError : public std::exception
{
public:
    PersonError(const std::string& message)
    {
        this->message = message;
    }
    // Константная функция, которая возвращает указатель на константные символы
    const char* what() const override
    {
        return message.c_str(); // c_str преобразует строку в указатель на символы
    }
private:
    std::string message;
};

class Person
{
public:
    Person(std::string name, unsigned int age)
    {
        if (name.length() > 3)
        {
            throw std::length_error{ "Недоумок-простофиля, в имени должно быть менее 4 символов!" };
        }

        if (!age || age > 150)
        {
            throw std::range_error{ "Неверный возраст, ты полуослик и олух!" };
        }

        this->name = name;
        this->age = age;
        std::cout << "Объект класса человека был создан: " << this->name << std::endl;
    }
    ~Person()
    {
        std::cout << "Объект класса человека был очищен: " << name << std::endl;
    }
    void PrintInfo()
    {
        std::cout << "Имя: " << name << ". Возраст: " << age << std::endl;
    }
private:
    std::string name;
    unsigned int age;
};

double Divide(int number1, int number2)
{
    if (!number2) // number2 == 0
    {
        throw 0; // выкидываем программе исключение типа данных int
    }
    if (number2 > number1)
    {
        throw std::string("Знаменатель больше числителя, дубина!");
    }
    return number1 / number2;
}

int main()
{
    setlocale(LC_ALL, "Ru");
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);

    /*try
    {
        try
        {
            std::cout << Divide(7, 8) << std::endl;
        }
        catch (const int intMessage)
        {
            std::cout << "Возникла int-овая ошибка, ты дурень x2:" << intMessage << std::endl;
        }
        std::cout << "Отработала вложенная конструкция!" << std::endl;
    }
    catch (const std::string& errorMessage) 
    {
        std::cout << "Возникла ошибка, ты дурень: " << errorMessage << std::endl;
    }    
    std::cout << "Я работаю дальше!" << std::endl;
    std::cout << std::endl;*/

    try
    {
        Person chelovek1("Leo", 17);
        chelovek1.PrintInfo();

        Person chelovek2("Leo", 170);
        chelovek1.PrintInfo();
    }
    catch (const std::range_error& ageException)
    {
        std::cout << ageException.what() << std::endl;        
    }
    catch (const std::length_error& nameException)
    {
        std::cout << nameException.what() << std::endl;
    }

    std::cout << "негры пашут дальше!" << std::endl;

    system("pause");
}

//      Обработка исключительных ситуаций
// Цель данного инструмента - позволить программе работать корректно при возникновении ошибок. 
// Пример: присваивание некорректного типа данных, разрыв соединения при передаче файлов по сети
// Ошибки бывают следующего характера:
// - Ошибки логики построения программы. Например, ошибка "индекса вне диапазона";
// - Ошибки среды выполнения программы, которые выходят за рамки контроля разработчика. Например, ошибка "сетевая служба недоступна".
// Исключительные ситуации нужны по следующим причинам:
// - Исключение заставляет программный код распознавать УСЛОВИЕ ошибки и сделать определенное действие;
// - Исключение переходит к точке стека вызовов, которая может обработать ошибку;
// - Исключение позволяет четко разделить код, который обнаруживает ошибку и код, который обрабатывает ошибку.
//  try
//  {
//       код, который нужно обработать
//  }
//  catch (const std::exception&) // ошибка, которая может возникнуть
//  {
//
//  }
// (...) - говорят конструкции catch обработать любое исключение
// throw - позволяет указать программе, что при определенном условии может возникнуть ошибка. Дословно ошибку мы выкидываем в программу
// catch(const char* message) - позволяет программе поймать ошибку, которую кинули из какого-либо условия
// При обработке исключения при передаче объекта оператору throw блок catch получает копию объекта. Она существует только в пределах блока catch! Для значений базовых типов (int, double, char, bool) копирование может не особо повлиять на проихводительность. При передаче объектов классов или структур издержки могут быть больше. В таком случае объекты лучше передавать по ссылке!
// У пользовательских типов данных (классы, структуры) при возникновении исключения будет вызван деструктор
// Конструкция try-catch может быть вложенной. Если исключение возникает во вложенной конструкции, то программа сначала ищет во вложенной конструкции блок catch, который обрабатывает нужный тип исключения. Если такой блок не найден, то программа начинает искать аналогичный блок во внешней конструкции.

//      std::exception
// Все исключения описываются типом exception, определенным в классе exception. При обработке исключений можно использовать этот класс.
// На основе этого класса можно создать свой тип исключений

//      Типы исключений
// runtime_error - общий тип исключений, который возникает во время выполнения программы;
// range_error - исключение, которое возникает, когда значение выходит за диапазон значений (диапазон в цикле);
// overflow_error - исключение, которое возникает, если значение превышает диапазон значений (например, инициализация динамического массива из пяти значений дополнительным шестым);
// underflow_error - исключение, которое возникает, если результат имеет недопустимое меньшее или отрицательное значение (выход за нижнюю границу значений, например, проверка на возраст);
// logic_error - исключение, которое возникает при появлении логических ошибок;
// domain_error - возникает для некоторого значения, которое передается в функцию, для которого не определен результат;
// invalid_argument - возникает при передаче некорректного аргумента в функцию;
// length_error - возникает при попытке создать объект большего размера, чем нужно;
// out_of_range - возникает при попытке доступа к полям вне диапазона